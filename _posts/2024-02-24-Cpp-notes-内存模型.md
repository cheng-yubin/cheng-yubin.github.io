---
title: Cpp Notes 1
date: 2024-02-24 16:00:00 +0800
categories: [Notes]
tags: [Cpp]
pin: true
---

引用：https://blog.csdn.net/zju_fish1996/article/details/108858577

### 内存布局
程序的内存分布包括：
1. 代码段：存放可执行程序的机器码
2. 数据段：存放已初始化的全局和静态变量，常量数据（如字符串常量）
3. BSS(Block started by symbol)：存放未初始化或显式地初始化为0的全局和静态变量
4. Heap(堆)：从低地址向高地址增长，容量大于栈，用于程序中动态分配的内存
5. Stack(栈)：从高地址向低地址增长，由编译器自动管理分配，存放程序中的局部变量、函数参数值、返回变量等。  

可执行程序的文件包含BSS，data segment和code segment.

![layout](/assets/img/2024-02-24-Cpp-notes-内存模型/内存模型.webp)

### 内存对齐
结构体大小可能大于各个成员大小的总和，这是因为结构体内部成员进行了内存对齐。

为什么需要内存对齐？  
1. 使得数据读取更加高效
2. 某些平台下，不进行内存对齐会崩溃

内存对齐规则：
**有效对齐值**为结构体中最宽成员和编译器/用户指定对齐值中较小的一个。
1. 结构体起始地址为有效对齐值的整数倍
2. 结构体总大小为有效对齐值的整数倍
3. 结构体第一个成员偏移值为0，之后成员的偏移值为min(有效偏移值，自身大小)的整数倍，相当于每个成员和整个结构体都需要对齐。

### 内存碎片
- 内部碎片：系统分配的内存大于实际所需内存（由于对齐机制）
- 外部碎片：不断分配回收不同大小的内存，由于内存分布散乱，较大内存无法分配

### 继承类布局
如果一个类继承另一个类，那么它自身数据在父类之后

如果当前类包含虚函数，那么会在类的最前端占用4个字节，用于存储虚函数表指针，指向一个虚函数表。虚函数表中包含当前类的所有虚函数指针。

### 字节序
大于一个字节的值被称作多字节量，存在高位有效字节和低位有效字节。
- 小端：低位有效字节存储于较低的内存位置
- 大端：高位有效字节存储与较低的内存位置  

PC机默认小端存储。

### 高速缓存
处理器使用Cache作为内存到CPU的缓冲。为了提高程序性能，要尽量避免缓存命中失败。一般而言，遵循尽可能地集中访问连续内存。一是内存空间要尽可能连续，二是访问时序尽可能连续。节点式的数据结构遍历就会差于内存连续性的容器。

### new运算符
new是用于动态内存分配的运算符，主要完成两个操作：
1. 调用operator new()函数，动态分配内存。
2. 在动态分配的内存上调用构造函数，以初始化相应类型的对象，并返回首地址。

调用new时，会在堆中查找一个足够大的剩余空间，分配并返回；当调用delete时，则会将该内存标记为不可使用，而指针仍然指向该内存。

```cpp
// new 一般表达式
p_var = new type(initializer);

// 对象数组表达式
p_var = new type[size];
delete []p_var;

// 二维数组表达式
auto p = new double[2][2];
```

placement new 在已经分配好的特定内存创建对象。使用如下语句，其中ptr是指定的内存首地址。
```cpp
A* p = new(ptr) A;
```

为什么new效率较低？
1. 系统调用带来的开销。申请内存会从用户模式切换到内核模式，上下文切换会消耗一定时间。
2. 分配可能是带锁的，难以并行化
3. new是一个通用接口，封装了很多细节，在设计上无法兼顾一些特殊场景的优化。