---
title: Cpp Notes：问答
date: 2024-02-24 16:00:00 +0800
categories: [Notes]
tags: [Cpp]
pin: true
---

### 解释封装、继承和多态
封装是将数据和方法包装在类中，实现数据的隐藏和保护。通过封装，可以将数据隐藏在类内部，并提供公共接口来访问和操作这些数据，从而实现信息隐藏、数据安全性、代码模块化的目标。

继承是一种机制，允许一个类从另一个类中继承属性和行为。子类可以继承父类的成员变量和成员函数，并添加自己特有的成员变量和成员函数。通常使用‘:’来指定继承关系。

多态允许相同的函数接口在不同对象上表现出不同的行为，实现多态主要依靠虚函数和动态绑定。通过使用基类指针或引用调用虚函数时，程序会根据运行时实际对象类型来确定调用的函数。

多态的优点：
1. 创建统一接口，以便处理具有不同类型但具有相似功能和行为的对象
2. 简化代码逻辑，将通用操作放在基类定义，并使用派生类覆盖特定功能，减少代码冗余，提高可维护性
3. 扩展性和灵活性，通过添加新的派生类并重写虚函数，可以轻松扩展和修改现有的代码结构。

### 如何处理内存泄露问题？
1. 显式释放内存：使用动态内存分配（new、malloc）后，务必使用相应的释放操作（delete、free）。
2. 智能指针：使用shared_ptr和unique_ptr自动管理内存资源。
3. RAII: 一种编程范式，在对象构造函数中获取资源，在析构函数中释放资源。利用栈上对象生命周期结束自动调用析构函数的特性，确保资源得到及时正确的释放。
4. 使用容器类和标准库：使用std::vector，std::string等，简化内存管理工作。
5. 遵循良好的代码规范：避免多层级指针引用，避免过度复杂的嵌套结构等。
6. 内存分析工具：使用专门的内存分析工具来检查和诊断程序。

### 解释栈和堆的区别
1. 内存分配方式不同：栈上变量由编译器自动分配释放，堆上变量手动分配和释放。
2. 空间大小限制：栈大小通常固定且较小，由操作系统或编译器决定。堆可以根据需要动态增大或减小空间。
3. 分配速度：栈上变量分配速度更快，只需移动指针即可完成。堆上变量分配需要在运行时进行内存管理，相对较慢。
4. 生命周期：栈上变量具有局部性，函数执行结束后自动销毁。堆上变量可以在不同函数间共享，并且需要手动释放。
5. 数据访问方式：栈上变量访问速度更快，因为存放在连续内存块中；堆上变量通过指针访问，并且可能散布在不同内存位置。
6. 使用场景：栈主要保存局部变量、函数参数、返回值等；堆一般用于动态创建的对象、大型数据结构等。

### 析构函数
C++类中一个特殊的成员函数，用于在对象生命周期结束时进行清理和资源回收。当存在继承关系时，子类的析构函数会自动调用父类的析构函数，以逐层清理和回收资源。析构函数没有参数和返回值。

### const关键字作用
const用于声明常量，可以用于变量、函数参数、函数返回值、成员函数。  
1. 声明常量变量，表示其值不能被修改。
2. 函数参数中的变量，表示该参数在函数内部不能被修改。
3. 常成员函数，表示该成员函数不会修改对象的装量，可以在常对象上调用。

```cpp
// 常量变量
const int MAX_VALUE = 100;

// 常量函数参数
void PrintName(const std::string& name) {
    // ...
}

class A {
private:
    int data_;
public:
    int GetData() const {
        return data_;
    }
}
```

### 引用和指针区别
1. 初始化：引用必须在声明时初始化，并且不能改变绑定的对象；指针可以在任何时候初始化，并且可以修改指向的对象。
2. 空值：指针具有空值nullptr, 引用没有空值。
3. 指针可以进行内存地址的算术运算，可以通过解引用访问所执行的对象；引用不直接支持内存地址操作，它是被绑定对象的别名。

```cpp
int a = 1;
int& ar = a;
// 变量a的地址和引用ar的地址相同。
```

### 模板类和模板函数
模板类和模板函数是泛型编程工具，允许以通用的方式定义适用于不同数据类型的类和函数。

模板类是使用一个或多个类型参数来定义的类。通过在类定义中使用类型参数，可以使得类中的成员、方法、构造函数等具有通用性，并且可以根据实际需求进行实例化。

例如一个模板类Container的实现：
```cpp
template <typename T>
class Container {
private:
	T data_;
public:
	Container(T value) : data_(value) {}
	void print() {
		cout << "Data: " << data_ << endl;
	}
};
```

### C++中异常处理机制如何工作？
异常处理机制允许我们在程序运行时检查和处理可能发生的异常情况。异常是指程序执行期间出现的意外或不正常情况，例如除以零、无效输入等。异常处理机制可以帮助我们优雅地处理这些异常，避免程序崩溃或产生未定义行为。

在C++中，使用try-catch块来捕获和处理异常。try块用于包含可能引发异常的程序段，catch块用于捕获并处理异常。

最后一个catch块使用省略号（...）作为异常类型，充作通配符，可以捕获其他未被前面catch块捕获到的异常。

```cpp
try {
    // 可能引发异常的代码
}
catch (ExceptionType1 e1) {
    // 处理 ExceptionType1 类型的异常
}
catch (ExceptionType2 e2) {
    // 处理 ExceptionType2 类型的异常
}
// ...
catch (...) {
    // 处理其他类型的异常（通配符）
}
```

### 列举并解释STL中常用容器
- vector: 动态数组，运行时自动扩展和收缩大小。以连续的内存块存储元素，支持随机访问、尾部插入和删除等操作。
- list: 双向链表，每个节点包含指向前一个节点和后一个节点的指针。相比于vector，list在任意位置进行插入和删除操作更加高效，但随机访问较慢。
- deque: 双端队列，类似vector，支持首尾两端进行高效插入和删除。
- stack: 后进先出（LIFO）的容器适配器，基于其他底层容器实现。只允许在末尾进行插入和删除，且只能访问最顶端的元素。
- queue: 先进先出（FIFO）的容器适配器，基于其他底层容器实现。在尾部插入数据，在头部移除数据。
- map: 关联容器，存储键值对。根据键值进行排序和查找，具有较快的插入和删除操作。每个键在容器中唯一。
- set: 关联容器，存储唯一的值。自动将元素排序，并支持高效的插入、查找和删除操作。
- unordered_map: 基于哈希表实现的关联容器，通过哈希函数来存储和访问元素。相比于map，插入和查找操作通常更快，但不保证元素的顺序。
- unordered_set: 基于哈希表实现的集合容器，存储唯一的值并支持高效地插入、查找和删除操作。

### STL迭代器
STL迭代器是一种用于遍历容器中元素的抽象概念，可以让我们以统一的方式访问容器中的元素，而不依赖于容器的具体实现。迭代器类似于指针，提供了对容器中元素的访问、遍历和操作功能。

### 命名空间
命名空间是一种组织代码的机制，防止不同代码之间的名称冲突。它提供了一种将相关的函数、类、变量等标识符分组的方式。

命名空间的作用：
1. 避免名称冲突：当多个库或模块中存在相同名称的函数、类、变量时，使用命名空间可以避免冲突，因为每个命名空间内的标识符都是唯一的。
2. 组织代码：将相关功能的实体放入同一个命名空间，可以提高可读性和可维护性。
3. 全局声明隔离: 在命名空间中定义的实体默认情况下只对该命名空间内部可见。可以减少全局污染，并且只有在显式使用限定符时才能访问特定的命名空间。

```cpp
namespace Math {
	static int divide(const int a, const int b) {
		if (b == 0) {
			throw 1;
		}
		return a / b;
	}
}

int main() {
	int c = 0;
	try {
		c = Math::divide(1, 0);
	}
	catch (const char* reason) {
		cout << reason << endl;
	}
	catch (const int num) {
		cout << "err: " << num << endl;
	}
}
```