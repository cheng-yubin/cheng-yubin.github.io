---
title: Computer Networks Notes
date: 2023-12-21 14:00:00 +0800
categories: [Notes]
tags: [Computer Networks]
pin: true
---

## 计算机网络各层协议及作用
计算机网络的五层模型自顶向下包括：应用层、传输层、网络层、数据链路层、物理层。OSI（Open System Interconnection Model）七层模型在应用层下，还有表示层和会话层。  

- 应用层。为应用程序提供交互服务。应用层协议包括域名系统DNS、超文本传输协议（HTTP）、简单邮件传输协议（SMTP）、文件传输（FTP）、BitTorrent.

- 表示层。数据格式转换，如加解密、压缩解压缩等。

- 会话层。负责在网络两节点之间建立、维护和终止通信。

- 传输层。向进程提供通用的数据传输服务。主要包括TCP和UDP两种传输层协议。
    - TCP:面向连接的、可靠的数据传输服务，具有流量控制和拥塞控制。
    - UDP:无连接的、尽力而为的数据传输服务。

- 网络层：提供端到端的、尽力而为的数据报服务。因特网的网络层协议是IP协议。在控制平面通过路由选择协议建立路由表，在数据平面根据路由表对IP数据包存储转发。

- 数据链路层：将网络层数据包封装成帧，沿着路径传递到下一个节点。链路层协议包括以太网、WIFI等。

- 物理层：将帧中的比特传输到下一个节点。物理层协议与链路的介质进一步相关，例如以太网有多种物理层，如同轴电缆、双绞线、光纤。  


## TCP和UDP区别
TCP:面向连接；可靠的数据传输，有流量控制和拥塞控制；传输速度慢；首部最小20字节；适用要求可靠传输的应用，如文件传输。

UDP:无连接；尽力而为的数据传输，无流量和拥塞；传输速度快；首部8字节（源端口、目标端口、UDP长度、校验和），开销小；适用于实时应用，如实时多媒体应用，事务查询类应用，如DNS。

## TCP三次握手机制
第一次握手：客户端TCP请求建立连接，发送同步报文，SYN=1，seqn=随机序列号（client_isn）。客户端进入SYN_SENT状态。

第二次握手：服务器接收到同步报文，如同意连接，发送同步确认报文，SYN=1, ACK=1, seqn=随机序列号（server_isn），ackn = client_isn + 1. 服务器进入SYN_RECV状态，为该连接分配TCP缓存和变量。

第三次握手：客户端收到服务器确认后，向服务器发送确认报文。ACK=1，seqn=client_isn + 1, ackn = server_isn + 1, 客户端和服务器都进入ESTABLISHED状态。

## 为什么需要三次握手而不是两次
1. 防止已过期的连接请求的影响。两次握手即可的情况下，客户端发送的连接请求A由于网络原因没有到达，客户端重发连接请求B,服务器返回确认报文，建立连接传输数据，正常断开连接。这时连接请求A才刚刚到达服务器，那么服务器发送确认报文进入ESTABLISHED状态，但客户端已经是CLOSED状态，不会去关闭连接。这会导致服务器长时间单方面等待，造成资源浪费。

2. 三次握手才能让双方都确认自己和对方的发送接收能力均正常。

3. 告知对方自己的初始化序列号，并收到对方的确认。

## SYN泛洪攻击及防范
SYN泛洪攻击时DOS攻击的一种，利用TCP协议的缺陷，通过发送大量的同步报文，耗尽服务器CPU和内存资源。

原理：服务器在收到同步报文以后，进入SYN_RECV状态，分配并初始化连接变量和缓存。然后服务器发送同步确认报文，等待客户端的确认。如果客户端不发送ACK，服务器会重传同步确认报文，并在一段时间后关闭这个半连接。

## 三次握手连接阶段，最后一次ACK包丢失
服务端：没有收到ACK，会重发同步确认报文；重发指定次数后仍未收到，一段时间后自动关闭这个连接。

客户端：第三次握手丢失情况下，客户端向服务器发送数据，服务器会响应RST包。此时客户端知道第三次握手失败。

## 四次挥手过程
第一次挥手：客户端向服务器发送FIN=1,等待服务器确认。客户端进入FIN_WAIT_1.

第二次挥手：服务器向客户端发送ACK=1,服务器进入CLOSE_WAIT.

第三次挥手：服务器向客户端发送FIN=1，服务器进入LAST_ACK，客户端进入FIN_WAIT_2.

第四次挥手：客户端向服务器发送ACK=1，进入TIME_WAIT. 等待2倍最长报文段寿命后，客户端进入CLOSED. 服务器收到ACK后，进入CLOSED状态。

## 为什么连接三次握手，关闭要四次挥手
因为服务器收到客户端的FIN报文段后，可能还有一些数据要传输，不能马上关闭连接，但是会做出应答，即发送ACK报文段。接下来服务器继续发送数据，最后发送FIN报文来请求关闭连接。所以服务器的ACK和FIN一般会分开发送，导致多了一次。

## 客户端的TIME_WAIT为什么等待2MSL
1. 确保ACK报文到达服务器，从而使服务器正常关闭连接。2MSL = 客户端ACK报文1MSL超时 + 服务器FIN报文1MSL传输。

2. 保证本连接持续时间内产生的所有报文段从网络中消失。

## 建立连接后客户端出现故障
通过定时器和超时重传机制尝试获得确认，超过最大重传次数后自动断开连接。

## TIME_WAIT是服务器状态还是客户端状态
TIME_WAIT是主动断开连接一方的状态，一般情况下是客户端主动断开连接。TIME_WAIT需要等待2MSL,在大量短连接情况下，TIME_WAIT太多会消耗很多系统资源

## TIME_WAIT状态过多的后果及处理
对服务器来讲，短时间关闭大量连接会导致出现大量TIME_WAIT连接，严重消耗服务器资源；对客户端来讲，会导致端口资源被过多占用，无法创建新连接。

解决办法：服务器设置套接字选项避免TIME_WAIT状态，即使处于TIME_WAIT状态也进行重用。

## TCP协议如何保证可靠性
TCP提供校验和、序列号和确认应答、超时重传、滑动窗口、拥塞控制、流量控制等方法实现可靠性传输。

- 校验和：检查报文段是否出错。
- 序列号和确认应答：对报文段进行排序、去重，对于丢失或出错的报文段要求重发（快速重传）。
- 滑动窗口：提高报文传输的效率。
- 超时重传：应对丢包的情况。
- 拥塞控制：出现超时或重传表明出现拥塞迹象，降低发送速率。
- 流量控制：接收方告知接收窗口，使发送方控制发送的数据量。

## TCP滑动窗口
TCP的发送方维护发送窗口来提供流量控制。窗口的左边缘有接收方的ackn决定，窗口的右边缘由ackn + window决定。相当于接收方告诉发送方，自己还有多少可用的缓存空间。

接收方具有一个固定长度的接收缓冲区，缓冲区内部分数据收到已确认，是已用部分，剩余的是可用部分。akcn表示可用部分的开头，可用部分长度即为window的长度。

## 拥塞控制
发送方将丢包事件（包括超时或收到3个冗余ACK）作为出现网络拥塞的指示，将收到ACK作为网络畅通的指示。

发送方维护一个叫拥塞窗口的状态变量，位于拥塞窗口内的字节才会被发送。假设接收窗口很大，拥塞窗口限制了发送方能向网络中发送的流量的速率。

TCP使用了四种算法实现拥塞控制：
1. 慢启动：拥塞窗口初始值设为一个MSS,对于每个确认报文段，将拥塞窗口增加1个MSS,即拥塞窗口指数增长。
    - 当出现由超时指示的拥塞时，设置慢启动阈值为拥塞窗口的一半，然后将拥塞窗口重新设置为1，重新开始慢启动。
    - 当达到或超过拥塞阈值时，结束慢启动，进入拥塞避免模式。
    - 当检测到3个冗余ACK,执行快速重传并进入快速恢复模式。

2. 拥塞避免：保守地增加拥塞窗口，每个RTT增加1个MSS。例如拥塞窗口是10个MSS，那么每个被确认的报文段增加1/10个MSS，下一个RTT拥塞窗口为11个MSS.
    - 超时。设置慢启动阈值为拥塞窗口一般，进行慢启动。
    - 3个冗余ACK。执行快速重传并进入快速恢复模式。

3. 快速恢复：收到3个重复的冗余ack后，慢启动阈值设置为当前拥塞窗口的一半，设置当前拥塞窗口为慢启动阈值+3*MSS.
    - 重复ack到达时，拥塞窗口增加一个MSS。
    - 新的ack到达时，设置拥塞窗口为慢启动阈值，进行拥塞避免。

    - 注意：开始的+3和重复ack的+1都表面有乱序的报文段达到，网络很可能没有阻塞。如果仅仅将拥塞窗口减半，未确认的报文段可能接近甚至超过拥塞窗口了，那么此时数据几乎不发送，而新的ack到达时，滑动窗口右滑，有可能导致大量数据同时发送出去。因此在新的ack到达前进行透支，到达后则将拥塞窗口还原到慢启动阈值。

![](/assets/img/2023-12-21-computer-networks-notes/TCP拥塞控制.png)

## HTTP常见状态码
- 1XX:信息状态码（正在处理）
- 2XX:成功状态码（正常处理完毕）
    - 200：ok
- 3XX:重定向状态码
    - 301：永久移动
    - 302：临时移动
- 4XX:客户端错误状态码
    - 400：请求有语法错误
    - 403：收到请求，但拒绝提供服务
    - 404：找不到请求的网页
- 5XX:服务器错误状态码
    - 500：服务器内部错误，无法完成请求

## 状态码301与302区别
相同点：都表示重定向，浏览器拿到这个状态码后会自动跳转到新的URL地址。

不同点：301表示旧地址资源已经被永久移除；302表示旧地址的资源还在。

## HTTP常用的请求方式
- GET:获取资源
- POST:传输实体主体
- PUT:上传文件
- DELETE:删除文件
- HEAD:只返回报文首部
- PATCH:对资源部分修改
- OPTIONS:查询指定url支持的方法
- CONNECT:要求用隧道协议代理连接
- TRACE:将通信路径返回给客户端

PUT, DELETE, POST, GET 理解为客户端对服务端的增删改查。

## GET请求和POST请求区别
使用上区别：
- GET使用URL或Cookie传参，POST将数据放在BODY中
- GET提交的数据有长度限制，POST数据可以很大
- POST比GET安全，因为数据在地址栏不可见

本质区别：GET请求时幂等性的，POST请求不是。

## HTTP长连接和短连接
在HTTP/1.0中，默认使用短连接。即浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

从HTTP/1.1起，默认使用长连接，当一个网页打开完成后，TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

使用长连接的HTTP协议，会在首部行加入：connection:keep-alive. HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

## HTTP请求报文和响应报文的格式
请求报文格式：
1. 请求行（request line）
2. 首部行（header line）
3. 空行
4. 请求主体

```
GET / HTTP/1.1
Host: baidu.com
Connection: Keep-Alive

data
// 换行为\r\n
```

响应报文格式：  
1. 状态行（status line）
2. 首部行（header line）
3. 空行
4. 实体体（entity body）

```
HTTP/1.1 200 ok
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Last-Modified: xxx
Content-Length: 6821
Content-Type: text/html

<html>
    <head>
        <title>HTTP响应示例<title>
    </head>
    <body>
        Hello HTTP!
    </body>
</html>
```

## HTTP1.0和HTTP1.1区别
1. 长连接：HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少TCP连接建立和关闭的消耗和延迟

2. Host头域：在HTTP1.0中认为每台服务器绑定一个唯一的IP地址，因此请求中的URL没有传递主机名。但一台物理主机上可以存在多个虚拟主机，共享一个IP地址。HTTP1.1的请求报文和响应报文都支持Host头域，且请求报文中没有Host会报错（400，Bad Request）。

3. Range头域：支持断点续传功能，允许只请求资源的一个部分，返回码是206（Partial Content）。

## HTTP1.1和HTTP2.0区别
1. 多路复用：HTTP1.1中，为了避免队首阻塞（HOL），通常采用多个TCP连接并行，一方面解决HOL，另一方面抢占带宽。HTTP2.0为了使TCP拥塞控制正常运行，同时避免HOL问题，将HTTP报文划分成帧，并且多个报文交替发送，从而减小用户的感知延迟。

2. 二进制解析：成帧子层对帧进行二进制编码，更加高效和不容易出错。

3. 头部压缩：通过字典来实现header的体积

4. 服务器推送：允许服务器为客户端的一个请求发送多个响应，而无需等待客户端对这些对象的HTTP请求，消除了等待这些请求的额外时延。

## HTTP和HTTPS的区别
HTTP：端口号80；无加密，安全性较差；资源消耗较少；不需要证数；运行在TCP协议上；

HTTPS：端口号443；有加密，安全性较高；由于加密资源消耗更多；需要证书；运行在SSL协议上，SSL运行在TCP上。

## HTTPS优缺点
优点：

1. 认证服务器和客户端，保证数据发送到正确的客户机和服务器。
2. 由SSL+HTTP构建的可加密、身份认证的网络协议，安全性更高。
3. 大幅增加了中间人攻击成本。

缺点：  
1. 资源消耗更多
2. 安全性是有范围的
3. 仍存在中间人攻击等风险。


## HTTPS原理
1. 客户端请求HTTPS网址，连接到server的443端口。
2. 服务器响应请求，将数字证书传递给客户端。
3. 客户端解析证书并进行验证。若证书无误，取出服务器公钥A，生成随机数KEY，使用A加密。
4. 客户端将加密后的KEY发送给服务器，作为对称加密密钥。
5. 服务器收到加密后的KEY使用私钥解密
6. 双方通过对称加密传输数据。


## 浏览器输入www.baidu.com后执行的全过程
1. 域名解析：浏览器查自己的DNS缓存；若没有，查操作系统的DNS缓存；若没有，查操作系统的hosts文件；若没有，向本地域名服务器查询DNS缓存；若没有，进行迭代查询。本地DNS服务器将IP返回给操作系统，缓存IP。

2. 发起TCP三次握手，建立TCP连接。浏览器以一个随机端口向服务端的web程序80端口发起TCP连接。

3. TCP连接后，浏览器发起HTTP请求。

4. 服务器响应HTTP请求，将HTML代码封装在响应报文的实体中，传输给浏览器

5. 浏览器解析HTML代码，请求HTML中的资源。

6. 浏览器对页面进行渲染，呈现给用户。

## 什么是Cookie和Session
Cookie: 服务器发送到用户浏览器并保存在本地的一小块数据，会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常用于告知服务端两个请求是否来自同一个浏览器，如保持用户登录状态。Cookie使得无状态的HTTP协议能够记录稳定的状态信息。

Cookie主要用于
- 会话状态管理（用户登录状态、购物车、游戏分数等）
- 个性化设置（用户自定义设置等）
- 浏览器行为跟踪（跟踪分析用户行为等）

Session：存储特定用户会话所需的属性及配置信息。当用户在应用程序的web页之间跳转时，存储在Session对象里的变量将不会丢失。

## Cookie和Session是如何配合的？
用户第一次请求服务器时，服务器根据用户提交的相关信息，创建对应的Session, 请求回复时将唯一标志符号SessionID返回给客户端。客户端将SessionID存入Cookie中，并记录对应的域名。

用户第二次访问时，请求会自动判断该域名下有无Cookie信息，若存在就将Cookie信息也发送给服务器，服务器从Cookie中获取SessionID，再查找对应的Session, 若没有找到说明用户没有登录或登录失效，找到则说明用户已经登录可以执行后续操作。

## Cookie与Session区别
1. 作用范围：Cookie保存在客户端、Session保存在服务器。
2. 保存方式：Cookie只能保存ASCII码，Session可以任意数据结构。
3. 有效期不同：Cookie可以长时间保存，如默认登录功能，Session一般失效期较短，客户端关闭或者超时都会失效。

## 如何考虑分布式Session问题
1. 客户端存储：直接将信息存储在Cookie中
2. 服务器使用IP_HASH策略，按照访问的IP地址的hash分配，同一IP固定访问一个后台服务器，避免同一Session需要被不同服务器访问
3. Session复制：任何一个服务器上的Session改变，该节点将Session内容序列化，广播给其他节点
4. 共享Session：使用缓存中间件如redis统一管理，保障分发到每个服务器的响应结果都一致。

## 什么是DDos攻击
分布式拒绝服务攻击（Distributed Denial of Service）。Dos攻击如下：
1. 客户端向服务器发送TCP请求
2. 服务端确认请求
3. 客户端不向服务器发送确认，服务器一直等待来自客户端的确认

DDos采用分布式方法，在网络上控制多台肉鸡发起Dos攻击

对于DDos攻击的防御方法：
1. 减少SYN timeout时间
2. 限制同时打开的SYN半连接数量

## 什么是XSS攻击
跨站脚本（Cross-site scripting）,这种攻击是由于服务器将攻击者存储的数据原原本本显示给其他用户所致，比如存在XSS漏洞的论坛，用户发帖时就可以引入带有"script"标签的代码，导致恶意代码的执行。

## SQL注入
SQL注入就是在用户输入的字符串中加入SQL语句，如果程序忽略检查，那么注入的SQL语句就会被数据库服务器误认为是正常的SQL语句运行，攻击者就可以执行计划外的命令或访问未被授权的数据。

避免方法：
1. 限制数据库权限
2. 对进入数据库的特殊字符进行转义处理
3. 提供参数化的查询接口，不要使用原生的SQL.

## 负载均衡算法
多台服务器以对称的方式组成一个服务器集合，每台服务器具有相等的地位，能相互分担负载。
1. 轮询法：将请求按照顺序轮流分配到服务器上
2. 随机法：随机获得一台服务器
3. 哈希法：通过IP地址哈希化确定要选择的服务器编号
4. 加权轮询：根据服务器性能不同进行加权。
